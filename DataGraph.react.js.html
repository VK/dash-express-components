<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      DataGraph.react.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><ul><li class="menu-li"><a href='https://github.com/VK/dash-express-components' class=' menu-link' id='' target='_blank'>Github</a></li></ul><div class="accordion collapsed" id="6964435" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="ConfigReceiver.html">ConfigReceiver</a></li><li class="accordion-list" id=""><a href="Configurator.html">Configurator</a></li><li class="accordion-list" id=""><a href="Filter.html">Filter</a></li><li class="accordion-list" id=""><a href="Graph.html">Graph</a></li><li class="accordion-list" id=""><a href="MetaCheck.html">MetaCheck</a></li><li class="accordion-list" id=""><a href="Plotter.html">Plotter</a></li><li class="accordion-list" id=""><a href="Transform.html">Transform</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        DataGraph.react.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Graph from './Graph.react';
import { none } from 'ramda';

class DataGraph extends Component {
    constructor(props) {
        super(props);

        const data = this.checkData(props.data);
        const defParams = props.defParams || this.getDefaultDefParams(data);
        

        this.state = {
            data: data,
            defParams,
            meta: this.getMeta(data),
            figure: this.getFigure(defParams, data),
        };

        this.handleGraphSetProps = this.handleGraphSetProps.bind(this);
    }

    checkData(data) {
        // if data is none ore empty create a dummy data element
        if (!data || Object.keys(data).length === 0) {
            return { no_data: [1, 2, 3] };
        }
        return data;
    }

    UNSAFE_componentWillReceiveProps(newProps) {
        if (newProps.defParams !== this.props.defParams || newProps.data !== this.props.data) {

            const defParams = newProps.defParams || this.getDefaultDefParams(newProps.data);
            const data = this.checkData(newProps.data);

            const meta = this.getMeta(data);
            const figure = this.getFigure(defParams, data);

            this.setState({ defParams, data: data, meta: meta, figure: figure });

            if (this.props.setProps) {
                this.props.setProps({ defParams, data: data, meta: meta, figure: figure });
            }
        }
    }


    handleGraphSetProps(updatedProps) {
        const defParams = updatedProps.defParams || this.state.defParams;
        const data = updatedProps.data || this.state.data;

        // Check if defParams have changed
        const defParamsChanged = JSON.stringify(defParams) !== JSON.stringify(this.state.defParams);

        if (defParamsChanged) {
            const figure = this.getFigure(defParams, data);

            if (this.props.setProps) {
                this.props.setProps({ ...updatedProps, figure });
            }

            this.setState({ ...updatedProps, figure, defParams });
        } else {
            if (this.props.setProps) {
                this.props.setProps(updatedProps);
            }

            this.setState(updatedProps);
        }
    }

    getDefaultDefParams(data) {
        const dimensions = Object.keys(data);
        return {
            filter: [],
            transform: [],
            plot: {
                type: "table",
                params: {
                    dimensions
                }
            }
        };
    }

    getMeta(data) {
        const largeThreshold = 1000;

        function parseObjectCat(key) {
            const cat = [...new Set(data[key])];
            if (cat.length > largeThreshold) {
                return {
                    type: "categorical",
                    large: true,
                    cat: []
                };
            }
            return {
                type: "categorical",
                cat
            };
        }

        function parse(key, val) {
            if (val === "categorical") {
                const cat = [...new Set(data[key])];
                if (cat.length > largeThreshold) {
                    return {
                        type: "categorical",
                        large: true,
                        cat: []
                    };
                }
                return {
                    type: "categorical",
                    cat
                };
            } else if (val === "boolean") {
                return {
                    type: "boolean"
                };
            } else if (val === "temporal") {
                const values = data[key].filter(v => v != null).map(v => new Date(v));
                const min = new Date(Math.min.apply(null, values));
                const max = new Date(Math.max.apply(null, values));
                const median = new Date(values.sort((a, b) => a - b)[Math.floor(values.length / 2)]);
                return {
                    type: "temporal",
                    median,
                    min,
                    max
                };
            } else if (val === "numerical") {
                const values = data[key].filter(v => v != null).map(Number);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const median = values.sort((a, b) => a - b)[Math.floor(values.length / 2)];
                return {
                    type: "numerical",
                    median,
                    min,
                    max
                };
            } else {
                return parseObjectCat(key);
            }
        }

        return Object.keys(data).reduce((meta, key) => {
            const sampleValue = data[key][0];
            const dataType = typeof sampleValue;
            let inferredType;

            if (dataType === "string") {
                inferredType = isNaN(Date.parse(sampleValue)) ? "categorical" : "temporal";
            } else if (dataType === "boolean") {
                inferredType = "boolean";
            } else if (dataType === "number") {
                inferredType = "numerical";
            } else {
                inferredType = "categorical";
            }

            meta[key] = parse(key, inferredType);
            return meta;
        }, {});
    }

    getFigure(defParams, data) {
        if (!defParams || !defParams.plot || !defParams.plot.params) {
            return { data: [], layout: {} };
        }

        const { type, params } = defParams.plot;
        const figure = { data: [], layout: {} };

        const {
            x, y, color, symbol, facet_col, facet_row, facet_col_wrap,
            log_x, log_y, reversed_x, reversed_y, range_x, range_y,
            indep_x, indep_y, cat_x, cat_y, scatter_mode
        } = params;

        const createTrace = (group, name, xaxis = 'x', yaxis = 'y') => {
            const trace = {
                x: group.data[x],
                y: group.data[y],
                mode: (scatter_mode) ? scatter_mode : 'markers',
                type,
                name,
                xaxis,
                yaxis
            };

            if (color) {
                if (this.isNumerical(data[color])) {
                    trace.marker = { color: group.data[color] };
                } else {
                    trace.marker = { color: group.colorName };
                }
            }

            if (symbol &amp;&amp; type === 'scatter') trace.marker = { ...trace.marker, symbol: group.data[symbol] };
            if (cat_x) trace.x = group.data[cat_x];
            if (cat_y) trace.y = group.data[cat_y];

            return trace;
        };

        const getCategoryList = (data, category) => {
            return [...new Set(data[category])].sort();
        };

        const rowCategories = facet_row ? getCategoryList(data, facet_row) : [null];
        const colCategories = facet_col ? getCategoryList(data, facet_col) : [null];
        let num_of_rows = rowCategories.length;
        let num_of_cols = colCategories.length;

        if (facet_col_wrap &amp;&amp; !facet_row) {
            num_of_rows = Math.ceil(num_of_cols / facet_col_wrap);
            num_of_cols = Math.min(num_of_cols, facet_col_wrap);
        }

        const assignIndex = (category, value, categories) => {
            return categories.indexOf(value) + 1;
        };

        const groupedData = this.groupData(data, { color, facet_col, facet_row });
        figure.layout.grid = {
            rows: num_of_rows,
            columns: num_of_cols,
            subplots: [],
            roworder: 'bottom to top',
            pattern: (indep_x || indep_y) ? 'independent' : none
        };

        rowCategories.forEach((rowVal) => {
            colCategories.forEach((colVal) => {
                let currentRowIndex = assignIndex(facet_row, rowVal, rowCategories);
                let currentColIndex = assignIndex(facet_col, colVal, colCategories);

                if (facet_col_wrap &amp;&amp; !facet_row) {
                    currentRowIndex = Math.floor(currentColIndex / facet_col_wrap);
                    currentColIndex = currentColIndex % facet_col_wrap;
                }

                const matchingGroups = groupedData.filter(g => (
                    (!rowVal || g.row === rowVal) &amp;&amp;
                    (!colVal || g.col === colVal)
                ));

                matchingGroups.forEach((gr) => {

                    const trace = createTrace(
                        gr,
                        gr.name,
                        `x${currentColIndex === 1 ? '' : currentColIndex}`,
                        `y${currentRowIndex === 1 ? '' : currentRowIndex}`
                    );

                    figure.data.push(trace);

                    if (!figure.layout.grid.subplots[currentRowIndex - 1]) {
                        figure.layout.grid.subplots[currentRowIndex - 1] = [];
                    }

                    figure.layout.grid.subplots[currentRowIndex - 1][currentColIndex - 1] = `${trace.xaxis}${trace.yaxis}`;
                });
            });
        });

        if (log_x) figure.layout.xaxis = { type: 'log' };
        if (log_y) figure.layout.yaxis = { type: 'log' };
        if (reversed_x) figure.layout.xaxis = { ...figure.layout.xaxis, autorange: 'reversed' };
        if (reversed_y) figure.layout.yaxis = { ...figure.layout.yaxis, autorange: 'reversed' };
        if (range_x) figure.layout.xaxis = { ...figure.layout.xaxis, range: range_x };
        if (range_y) figure.layout.yaxis = { ...figure.layout.yaxis, range: range_y };

        if (type === 'imshow') {
            const groupedData = this.groupData(data, { facet_col, facet_row });
            figure.layout.grid = {
                rows: num_of_rows,
                columns: num_of_cols,
                subplots: [],
                roworder: 'bottom to top',
                pattern: (indep_x || indep_y) ? 'independent' : none
            };

            rowCategories.forEach((rowVal) => {
                colCategories.forEach((colVal) => {
                    let currentRowIndex = assignIndex(facet_row, rowVal, rowCategories);
                    let currentColIndex = assignIndex(facet_col, colVal, colCategories);

                    if (facet_col_wrap &amp;&amp; !facet_row) {
                        currentRowIndex = Math.floor(currentColIndex / facet_col_wrap);
                        currentColIndex = currentColIndex % facet_col_wrap;
                    }

                    const matchingGroups = groupedData.filter(g => (
                        (!rowVal || g.row === rowVal) &amp;&amp;
                        (!colVal || g.col === colVal)
                    ));

                    matchingGroups.forEach((gr) => {

                        const trace = {
                            z: gr.data[params.value],
                            x: gr.data[x],
                            y: gr.data[y],
                            type: 'heatmap',
                            name: gr.name,
                            xaxis: `x${currentColIndex === 1 ? '' : currentColIndex}`,
                            yaxis: `y${currentRowIndex === 1 ? '' : currentRowIndex}`
                        };

                        figure.data.push(trace);

                        if (!figure.layout.grid.subplots[currentRowIndex - 1]) {
                            figure.layout.grid.subplots[currentRowIndex - 1] = [];
                        }

                        figure.layout.grid.subplots[currentRowIndex - 1][currentColIndex - 1] = `${trace.xaxis}${trace.yaxis}`;
                    });
                });
            });
        }

        if (type === 'table') {
            return data;
        }

        return figure;
    }

    groupData(data, params) {
        var { color, symbol, facet_col, facet_row } = params;
        if (color &amp;&amp; this.isNumerical(data[color])) {
            color = null;
        }
        const groupByCols = [color, symbol, facet_col, facet_row].filter(Boolean);

        if (groupByCols.length === 0) {
            return [{ data, name: 'default', colorName: null }];
        }

        const groupedData = {};
        const groupKeys = {};

        data[Object.keys(data)[0]].forEach((_, idx) => {
            const groupKey = groupByCols.map(col => data[col][idx]).join('-');

            if (!groupedData[groupKey]) {
                groupedData[groupKey] = {};
                Object.keys(data).forEach(k => groupedData[groupKey][k] = []);
            }

            Object.keys(data).forEach(k => groupedData[groupKey][k].push(data[k][idx]));

            if (!groupKeys[groupKey]) {
                groupKeys[groupKey] = {
                    name: groupKey,
                    colorName: color ? data[color][idx] : null,
                    symbol: symbol ? data[symbol][idx] : null,
                    row: facet_row ? data[facet_row][idx] : null,
                    col: facet_col ? data[facet_col][idx] : null
                };
            }
        });

        return Object.keys(groupedData).map(key => ({
            data: groupedData[key],
            name: groupKeys[key].name,
            colorName: groupKeys[key].colorName,
            symbol: groupKeys[key].symbol,
            col: groupKeys[key].col,
            row: groupKeys[key].row
        }));
    }

    isNumerical(column) {
        return typeof column[0] === 'number';
    }

    render() {
        return (

            &lt;Graph
                id={this.props.id}
                defParams={this.state.defParams}
                meta={this.state.meta}
                figure={this.state.figure}
                setProps={this.handleGraphSetProps}
                showFilter={false}
                showTransform={false}
            />

        );
    }
}

/**
 * @typedef
 * @public
 * @enum {}
 */
DataGraph.propTypes = {
    id: PropTypes.string.isRequired,
    defParams: PropTypes.object,
    data: PropTypes.object,
    setProps: PropTypes.func,
};

DataGraph.defaultProps = {
    data: { "no_data": [1, 2, 3] },
};

/**
 * @private
 */
export default DataGraph;</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"ConfigReceiver","link":"<a href=\"ConfigReceiver.html\">ConfigReceiver</a>"},{"title":"Configurator","link":"<a href=\"Configurator.html\">Configurator</a>"},{"title":"Filter","link":"<a href=\"Filter.html\">Filter</a>"},{"title":"Graph","link":"<a href=\"Graph.html\">Graph</a>"},{"title":"MetaCheck","link":"<a href=\"MetaCheck.html\">MetaCheck</a>"},{"title":"Plotter","link":"<a href=\"Plotter.html\">Plotter</a>"},{"title":"Transform","link":"<a href=\"Transform.html\">Transform</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>
